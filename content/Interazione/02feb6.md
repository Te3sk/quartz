# affordance
relazione che nasce da un'interazione, solo quelle che si vanno ad incastrare bene si dicono affordable

# significanti
le affordance dicono *cosa*, i significanti dicono *come* e *dove*
il significante è un qualsiasi elemento che mi dicoe cosa posso fare e dove, a prescindere da se posso farlo o quando.

# mapping
altro elemento che incrementa l'understandig
*mapping means the relationship between the elements of two set of things*.
serve ad associare diversi gruppi di entità e a mapparli uno sull'altro.
mappando cerco di associare i miei controlli e le azioni a cui fanno riferimento.
il mapping è fortemente influenzato / deficittato dalle convenzioni culturali (indicatori serbatoio europeri/giapponesi)

esempio: office divide i bottoni in tab (layout, data, ...), mettere i significanti in posti associati all'azione (chiudi è sempre in alto a destra)

# feedback
è il ritorno che riceviamo dal sistema con cui stiamo interagendo.

esempio: la porta dell'ascensore non si chiude instant, ma deve aspettare x secondi, se però non ricevo un feedback continuo a pigiare il bottone compulsivamente finché non si chiudono le porte.

il feedback serve a comunicare il *risultato di un azione* (non di un processo). Il feedback deve avere due proprietà:
- *immediato*
- *informativo*
al mancare anche di una solo di queste due diventa controproducente.
- se passano più di 100 ms tra l'azione e il risultato dell'azione il cervello non associa la percezione all'azione. il ciclo azione-reazione umano è sopra i 100 ms
- se non è informativo l'utente va nel pallone
se il feedback è completamente mancante l'utente bene o male aspetta, se riceve un feedback che non capisce gli piglia male.

i feedback devono essere i meno possibili (less is more -sj). all'aumentare dei feedback, al perdere dell'informatività degli stessi, perdiamo l'attenzione degli utenti.

# conceptual model
è una spiegazione estremamente semplificata di come una cosa funzione. è ciò che sta nella mente del designer, ciò che si costruisce come struttura/modello mentale alla base della costruzione del sistema. 

esempio: file explorer, non esistono davvero i file, sono un modello concettuale (file system) ripreso dalle biblioteche, sistema gerarchico.

tutti vorrebbero semplificare il più possibile i modelli concettuali, perché più è semplice più è facile che l'utente lo internalizzi come vogliamo. Più semplifichiamo però, più *astraiamo*, questo riduce lo spazio di manovra.

esempio: il modello concettuale dei file system viene intaccato dai cloud storage sync. ero abituato a pensare al mio pc come una piccola libreria, hanno poi inventato i flag. 

# mental model
il modello concettuale pensato dal progettista e usato per l'implementazione del sistema non è uguale al modello mentale. Il modello mentale è quello ricreato dall'utente. Idealmente sono la stessa cosa, in pratica spesso non è così, maggiure saranno le differenze, maggiore saranno le difficoltà dell'utente nell'utilizzo del softwere

Per inferire il modello concettuale e far costruire all'utente il modello mentale si usano affordance, significanti e mapping

# system image
non si può trasferire il modello mentale all'utente. 
l'immagine di sistema è l'insieme delle info alle quali l'user ha accesso e sulla base delle quali crea il modello mentale.
l'immagine del sistema è composta dal prodotto e da tutte le info a contorno, ed è lo strumento con il quale l'user costruisce il modello mentale.
*when the system image is inchoherent or inappropriate the user cannot easily use the device*.
	